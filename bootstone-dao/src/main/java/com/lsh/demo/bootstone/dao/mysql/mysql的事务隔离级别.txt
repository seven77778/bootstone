什么是事务隔离？

任何支持事务的数据库，都必须具备四个特性，
分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），
也就是我们常说的事务ACID，这样才能保证事务（（Transaction）中数据的正确性。

而事务的隔离性就是指，多个并发的事务同时访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务间要相互进行隔离。

第一天，事务A访问了数据库，它干了一件事情，往数据库里加上了新来的牛人的名字，但是没有提交事务。

insert into T values (4, '牛D');

这时，来了另一个事务B，他要查询所有牛人的名字。

select Name from T;

这时，如果没有事务之间没有有效隔离，那么事务B返回的结果中就会出现“牛D”的名字。这就是“脏读（dirty read）”。

第二天，事务A访问了数据库，他要查看ID是1的牛人的名字，于是执行了

select Name from T where ID = 1;

这时，事务B来了，因为ID是1的牛人改名字了，所以要更新一下，然后提交了事务。

update T set Name = '不牛' where ID = 1;

接着，事务A还想再看看ID是1的牛人的名字，于是又执行了

select Name from T where ID = 1;

结果，两次读出来的ID是1的牛人名字竟然不相同，这就是不可重复读（unrepeatable read）


第三天，事务A访问了数据库，他想要看看数据库的牛人都有哪些，于是执行了

select * from T;

这时候，事务B来了，往数据库加入了一个新的牛人。

insert into T values(4, '牛D');

这时候，事务A忘了刚才的牛人都有哪些了，于是又执行了。

select * from T;

结果，第一次有三个牛人，第二次有四个牛人。

相信这个时候事务A就蒙了，刚才发生了什么？这种情况就叫“幻读（phantom problem）”。



为什么会出现“脏读”？因为没有“select”操作没有规矩。

为什么会出现“不可重复读”？因为“update”操作没有规矩。

为什么会出现“幻读”？因为“insert”和“delete”操作没有规矩。

“读未提（Read Uncommitted）”能预防啥？啥都预防不了。

“读提交（Read Committed）”能预防啥？使用“快照读（Snapshot Read）”，避免“脏读”，但是可能出现“不可重复读”和“幻读”。

“可重复读（Repeated Red）”能预防啥？使用“快照读（Snapshot Read）”，锁住被读取记录，避免出现“脏读”、“不可重复读”，但是可能出现“幻读”。

“串行化（Serializable）”能预防啥？排排坐，吃果果，有效避免“脏读”、“不可重复读”、“幻读”，不过效果谁用谁知道。