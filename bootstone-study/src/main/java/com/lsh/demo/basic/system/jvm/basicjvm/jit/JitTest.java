package com.lsh.demo.basic.system.jvm.basicjvm.jit;

/**
 *
 * 尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如HotSpot），都同时包含解释器和编译器。
 * 1.解释器直接执行，节约时间，相对于jit来说，节约内存
 * 2.jit快，是执行编译之后的代码快，但是编译后的代码也需要占用内存，如果一段代码执行频率很高，就会被jit编译成本地代码
 *
 * 解释器的执行，抽象的看是这样的：输入的代码 -> [ 解释器 解释执行 ] -> 执行结果
 *
 * 　　而要JIT编译然后再执行的话，抽象的看则是：输入的代码 -> [ 编译器 编译 ] -> 编译后的代码 -> [ 执行 ] -> 执行结果
 *
 * -- 如果被逃逸分析到没有逃逸的，即可进行锁消除
 *
 * 　　说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这个动作比“解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，对“只执行一次”的代码而言，解释执行其实总是比JIT编译执行要快。怎么算是“只执行一次的代码”呢？粗略说，下面两个条件同时满足时就是严格的“只执行一次”
 *
 *
 * 2.jit编译器选择哪些代码来编译呢，只执行一次的肯定不去编译了
 * -- 程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是热点代码呢？运行过程中会被即时编译器编译的“热点代码”有两类：
 *
 * 　　1、被多次调用的方法。
 *
 * 　　2、被多次执行的循环体。
 *
 *
 * -XX:+PrintCompilation 要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来
 */
public class JitTest {
}
