package com.lsh.demo.basic.thread;

/**
 * Created by lsh on 2019-05-05.
 *
 * “线程安全”也不是指线程的安全，而是指内存的安全
 * 目前主流操作系统都是多任务的，即多个进程同时运行。
 * 为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的
 *
 * 在程序里就对应于方法的局部变量。局部变量之所以是安全的，就是因为定义它的“位置”是在方法里。
 *
 * 这样一来安全是达到了，但是它的使用范围也就被限制在这个方法里了，其它方法想用也不用了啦
 *
 * 现实中往往会有一个变量需要多个方法都能够使用的情况，此时定义这个变量的“位置”就不能在方法里面了，
 * 而应该在方法外面，也就是 全局变量
 *
 * 引入 ThreadLocal 类
 * @see ThreadLocal
 *
 *
 * 小节一下：以上三种解决方案，其实都是在“耍花招”。 单线程肯定安全
 *
 * 第一种，找个只有自己知道的地方藏起来，当然安全了。 -- 每个方法中的内存 是安全的
 *
 * 第二种，每人复制1份，各玩各的，互不影响，当然也安全了。 -- ThreadLocal
 *
 * 第三种，更狠了，直接规定，只能读取，禁止修改，当然也安全了。--final修饰
 *
 * 再往下，加锁，但是加锁和释放锁，都需要花费一些性能
 *
 * 于是有了开销比较小的 CAS
 *
 * 并发量不大的情况下，还是OK的，拿到数据比较一下，是不是和之前的数据一致（ABA问题 版本号）
 * 如果并发量很高，数据基本上都会被修改的话，放弃cas
 *
 * CAS其实就是乐观锁
 *
 */
public class AboutThreadSafe {

}
