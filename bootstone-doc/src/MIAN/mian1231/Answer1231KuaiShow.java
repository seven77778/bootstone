public class Answer1231KuaiShow {

    /**
     * 谈一下项目
     * 谈一下对IOC和AOP的理解
     * Memchached 和 Redis 的区别
     * Redis的持久化实现
     * Redis的淘汰策略
     * 定期删除和惰性删除的区别、优缺点
     * IOC的原理是什么
     * Hashmap 的底层实现和原理
     * 手写一个，实现map的put方法
     *
     * 一. IoC(Inverse of Control:控制反转)是一种设计思想 或者说是某种模式。
     * 这个设计思想就是 将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。
     * IoC 在其他语言中也有应用，并非 Spring 特有。IoC 容器是 Spring 用来实现 IoC 的载体，
     * IoC 容器实际上就是个 Map(key，value),Map 中存放的是各种对象。
     *
     * IoC 最常见以及最合理的实现方式叫做依赖注入(Dependency Injection，简称 DI)。
     *
     * aop 面向切面
     * 切面收集日志，切面处理统一错误码
     *
     * 二、
     * 1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过 memcache 还可用于缓存其他东西，例如图片、视频等等。
     * 2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。
     * 3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘
     * 4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire
     * 设定，例如expire name 10
     * 5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从
     * 6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）
     * 7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复
     * 8、Redis支持数据的备份，即master-slave模式的数据备份
     *
     * 三、redis命令行输入info查看具体信息
     * redis持久化有2种方式 AOF RDB，从配置上来看：
     * 【RDB】内存快照 -- 定时写dump，数据备份没那么强，但是效率高，默认开启
     *  类似mysql中的.fri文件，存储的是二进制的文件
     * Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，
     * 在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：
     *
     * save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。
     * save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。
     * save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。
     * 优点：
     *  1.只有一个文件。效率比较aof高，它是fork一个子进程来搞持久化，文件通常比aof小
     *  2.子进程是共享主进程 内存的，如果存储快照的时候，有一个还没被写入磁盘的数据A被改成了b，最终修改也会被存到快照
     * 缺点：
     *  1.可能会丢失一些数据，AOF也可能会丢失一些数据吧
     *
     *
     * 【AOF】日志 -- 牺牲一些性能，换取更高的缓存一致性，默认关闭
     * 类似mysql 的sql文件
     * appendfsync always     #每次有数据修改发生时都会写入AOF文件。
     * appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。
     * appendfsync no         #从不同步。高效但是数据不会被持久化。
     *
     * 优点
     * 1.后写执行过的命令，防止一些错误的命令被记录，后执行也不会阻塞当前的操作
     * 风险：
     * 1.假如刚执行完一个命令就宕机了，这条命令不会被记录
     * 2.后执行写日志，虽然不会给当前的操作带来阻塞，但是有可能阻塞下一个操作，因为aof是在主线程中
     * 所有就有了 appendfsync 的配置，写磁盘日志是很慢的，写内存很快，适中方案就是一秒一次
     * 3.aof越写越多，越来越大，AOF 重写会阻塞吗? -- 不会，是个子进程
     *
     *
     * 【拓展】
     * Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。
     * 内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。
     * 这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。
     *
     * 四、
     * 没有用定时删除的，太浪费资源。
     * 定期删除 是 比如每隔100ms就随机删除一些过期的
     * 优点：随机删除一些，redis服务器的压力会小一些
     * 缺点：过期的key删除的不及时
     *
     * 惰性删除 是 设置了过期时间，但是不去删除，等你访问这个key的时候，查一下，如果过期了，在删除
     * 优点：访问到再去删，不会给CPU带来压力
     * 缺点：如果访问不到就不删除，越来越占用内存，这时候就有了内存淘汰机制，当内存不足时候，
     *
     *
     */
}
