 /**
     * 快速排序几种方法，写出时间复杂度
     */


    /**
     * 设计并实现一个简易的缓存框架，要求支持并发的读写和LRU缓存淘汰算法，并考虑性能
     */


    /**
     * 编写一个程序，开启3个线程，这3个线程的ID分别为A、B、C，3个线程交替打印1-100的整数，要求输出结果有序,
     *   样例Sample:
     * Thread1: 1
     * Thread2: 2
     * Thread3: 3
     * Thread1: 4
     * Thread2: 5
     * Thread3: 6
     * ....
     * Thread3: 99
     * Thread1: 100
     */


    /**
     * 遍历一个二叉树，打印出该路径中每个节点数字的和与给定目标值一致的有效路径。
     * 有效路径：从根节点到叶节点的路径。
     * 给定一个二叉树 :
     *      1
     *     / \
     *    2   4
     *   / \
     *  2   3
     * 目标值= 5时返回结果：
     * 1 2 2
     * 1 4
     */

    /**
     * 使用两个栈来实现队列的一些操作。
     * 队列应支持push(element)，pop() 和 top()，其中pop是弹出队列中的第一个(最前面的)元素。
     * pop和top方法都应该返回第一个元素的值。
     * 样例：比如push(1), pop(), push(2), push(3), top(), pop()，你应该返回1，2和2
     * 要求：仅使用两个栈来实现它，不使用任何其他数据结构，push，pop 和 top的复杂度都应该是均摊O(1)的
     *
     */


    /**
     * 比较一个源字符串和一个目标字符串，
     * 如果在源字符串中包含目标字符串全部字符，输出所包含的第一个最小子串；
     * 如果不存在，输出空。
     * ：样例
     * source = "BPDAUNZHGAHSIWBADNC"，target = "BDN" 满足要求的解  "BADN"
     * 要求：时间复杂度为O(n^2)
     */

     /**
          * 实现一个类似微博热搜前100名的，使用java数据结构
          * 最大堆
          */


           /**
               * 编写一个程序，开启3个线程，这3个线程的ID分别为A、B、C，3个线程交替打印1-100的整数，要求输出结果有序,
               * 样例Sample:
               * Thread1: 1
               * Thread2: 2
               * Thread3: 3
               * Thread1: 4
               * Thread2: 5
               * Thread3: 6
               * ....
               * Thread3: 99
               * Thread1: 100
               */