spring 事务底层是基于数据库事务和 aop 机制实现的
spring 会对使用了@Transaction 注解的 Bean，通过 aop 的方式创建一个代理对象
当调用代理对象的方法的时候，会进入到 spring 事务拦截器中，这里面会先判断方法上是否有@Transaction 注解
如果加了，那么会利用事务管理器创建一个数据库连接
并且修改数据库的连接的 autocommit 属性为 false，也就是禁止此链接自动提交，这是实现 spring 事务非常重要的一步
然后将会将这个连接放在 ThreadLocal 中，这里也是一个关键点，最终执行 sql 的连接需要和 spring 事务中的连接是同一个连接，
就是通过 ThreadLocal 共享连接的
然后执行当前业务方法，方法中准备执行 sql，通常我们会使用 orm 框架去执行 sql，比如我们常用的 mybatis、hibernate 等，
当这些框架执行 sql 的时候，会从上面的 ThreadLocal 中拿到刚才创建的数据库连接，然后使用这个连接去执行 sql
执行完业务方法之后，如果没有异常则 spring 会直接提交事务
如果出现了异常，且这个异常是需要回滚的，则会回滚事务，否则仍然会提交事务
spring 事务中的隔离级别其实对应的就是数据库的隔离级别，spring 会通过数据库的连接来设置隔离级别
spring 事务的传播机制是基于数据库连接来做的，一个数据库连接对应一个事务，如果传播机制配置为需要新开一个事务，
那么实际上就会新建一个连接，在这个新的连接上去执行 sql
上面说的这个过程稍微是简化版的，如果大家有兴趣的话，可以去研究一下@EnableTransactionManagement，
这个注解的作用是启用 spring 事务管理的功能，会对需要 spring 管理事务的 bean 创建代理对象，
上面还提到了 spring 事务拦截器，也是非常重要的一个点，他会拦截事务方法的执行，事务的所有操作都是在这个拦截器中完成的，
对应的类是：TransactionInterceptor